---
# üìì Python Programming - Error Handling and Debugging
---

## 1. Try-Except Blocks

**Error handling prevents programs from crashing due to unexpected issues.**

The basic structure:

```python
try:
    # Code that might raise an error
except:
    # Code to handle the error


‚û§ **Example:**



```python
try:
    num = int(input("Enter a number: "))
    print(f"Square: {num**2}")
except Exception as e:
    print("Invalid input! Please enter a number.\nException:", e)
```

## 2. Catching Specific Exceptions

```It's better to catch specific exceptions to handle different errors appropriately.```



```python
try:
    num = int(input("Enter a number: "))
    result = 10 / num
except ValueError:
    print("Please enter a valid number.")
except ZeroDivisionError:
    print("Division by zero is not allowed.")
except Exception as e:
    print("An unexpected error occurred:", e)
```

## 3. Using else & finally

- **else:** Runs if no exceptions occur.  

- **finally:** Runs no matter what (cleanup code).



```python
try:
    num = int(input("Enter a positive number: "))
except ValueError:
    print("Invalid input.")
else:
    print(f"You entered: {num}")
finally:
    print("This always runs.")
```

## 4. Generating and Creating Custom Exceptions

- You can use `raise` to generate exceptions.

- Custom exceptions are created by defining a new class that inherits from `Exception`.


**‚û§ Raising Exceptions Example:**


```python
age = -5

if age < 0:
    raise ValueError("Age cannot be negative.")
```

**‚û§ Custom Exception Example:**


```python
class NegativeAgeError(Exception):
    pass


age = -5

try:
    if age < 0:
        raise NegativeAgeError("Age cannot be negative.")
except NegativeAgeError as e:
    print(e)

```

## 5. Problem-Solving Strategies

‚úÖ Understand the error message.  

‚úÖ Use print statements or debugging tools to trace the problem.  

‚úÖ Break the code into smaller parts.  

‚úÖ Handle exceptions gracefully using try-except blocks.  

‚úÖ Anticipate common errors (e.g., invalid input, division by zero).  

‚úÖ Write custom exceptions for specific situations.  

## 6. Common Python Error Types

**Understanding common errors helps you debug faster:**

- **SyntaxError**: Invalid Python syntax

- **NameError**: Variable not defined

- **TypeError**: Wrong data type used

- **IndexError**: List index out of range

- **KeyError**: Dictionary key doesn't exist

- **FileNotFoundError**: File doesn't exist

- **ImportError**: Module can't be imported


```python
# Examples of common errors (commented out to avoid actual errors)

# 1. SyntaxError
# print("Hello World"  # Missing closing parenthesis

# 2. NameError
# print(undefined_variable)  # Variable not defined

# 3. TypeError
# result = "5" + 10  # Can't add string and integer

# 4. IndexError
# my_list = [1, 2, 3]
# print(my_list[5])  # Index 5 doesn't exist

# 5. KeyError
# my_dict = {"name": "John"}
# print(my_dict["age"])  # Key 'age' doesn't exist

# 6. FileNotFoundError
# with open("nonexistent.txt", "r") as file:
#     content = file.read()

# Let's demonstrate with proper error handling:
def demonstrate_errors():
    # Handling IndexError
    try:
        my_list = [1, 2, 3]
        print(my_list[5])
    except IndexError as e:
        print(f"IndexError caught: {e}")
    
    # Handling KeyError
    try:
        my_dict = {"name": "John"}
        print(my_dict["age"])
    except KeyError as e:
        print(f"KeyError caught: Missing key {e}")
    
    # Handling TypeError
    try:
        result = "5" + 10
    except TypeError as e:
        print(f"TypeError caught: {e}")

demonstrate_errors()
```

## 7. Debugging Techniques

**Different ways to find and fix bugs in your code:**

1. **Print Debugging**: Add print statements to track values

2. **Python Debugger (pdb)**: Step through code line by line

3. **IDE Debugger**: Use VS Code's built-in debugger

4. **Logging**: Better than print statements for production code

**‚û§ Print Debugging Example:**


```python
def calculate_average(numbers):
    print(f"DEBUG: Input numbers: {numbers}")  # Debug print
    
    total = 0
    for i, num in enumerate(numbers):
        total += num
        print(f"DEBUG: Step {i+1}, added {num}, total now: {total}")  # Debug print
    
    average = total / len(numbers)
    print(f"DEBUG: Final average: {average}")  # Debug print
    return average

# Test with debug prints
numbers = [10, 20, 30, 40]
result = calculate_average(numbers)
print(f"Average: {result}")

# Better approach: Use a debug flag
DEBUG = True

def debug_print(message):
    if DEBUG:
        print(f"[DEBUG] {message}")

def calculate_average_v2(numbers):
    debug_print(f"Input numbers: {numbers}")
    
    total = sum(numbers)
    debug_print(f"Sum: {total}")
    
    average = total / len(numbers)
    debug_print(f"Average: {average}")
    return average

print("\n--- Version 2 with debug flag ---")
result2 = calculate_average_v2([5, 15, 25])
print(f"Average: {result2}")
```

**‚û§ Using Python's Logging Module:**


```python
import logging

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

def divide_numbers(a, b):
    logging.debug(f"Starting division: {a} / {b}")
    
    try:
        if b == 0:
            logging.error("Division by zero attempted!")
            raise ZeroDivisionError("Cannot divide by zero")
        
        result = a / b
        logging.info(f"Division successful: {a} / {b} = {result}")
        return result
        
    except Exception as e:
        logging.exception("An error occurred during division")
        raise

# Test logging
print("=== Testing with logging ===")
try:
    result1 = divide_numbers(10, 2)
    print(f"Result 1: {result1}")
    
    result2 = divide_numbers(10, 0)
    print(f"Result 2: {result2}")
except ZeroDivisionError as e:
    print(f"Caught error: {e}")

# Different log levels
logging.debug("This is a debug message")
logging.info("This is an info message")
logging.warning("This is a warning message")
logging.error("This is an error message")
logging.critical("This is a critical message")
```

## 8. Assertions and Testing

**Assertions help catch bugs early by checking assumptions:**

- `assert` statement checks if a condition is True

- Raises `AssertionError` if condition is False

- Used for debugging and testing


```python
# Basic assertion examples
def calculate_factorial(n):
    assert n >= 0, "Factorial is not defined for negative numbers"
    assert isinstance(n, int), "Input must be an integer"
    
    if n == 0 or n == 1:
        return 1
    
    result = 1
    for i in range(2, n + 1):
        result *= i
    
    # Assert the result makes sense
    assert result > 0, "Factorial should always be positive"
    return result

# Test assertions
try:
    print(f"5! = {calculate_factorial(5)}")
    print(f"0! = {calculate_factorial(0)}")
    
    # This will raise AssertionError
    print(f"(-1)! = {calculate_factorial(-1)}")
except AssertionError as e:
    print(f"Assertion failed: {e}")

# Assertions in testing
def test_factorial():
    # Test cases
    assert calculate_factorial(0) == 1, "0! should be 1"
    assert calculate_factorial(1) == 1, "1! should be 1"
    assert calculate_factorial(5) == 120, "5! should be 120"
    print("All factorial tests passed!")

test_factorial()

# Assertions for debugging
def divide_positive_numbers(a, b):
    assert a > 0 and b > 0, "Both numbers must be positive"
    
    result = a / b
    
    # Check our assumption about the result
    assert result > 0, "Result should be positive when dividing positive numbers"
    return result

# Test
try:
    result = divide_positive_numbers(10, 2)
    print(f"Division result: {result}")
    
    # This will fail the assertion
    result = divide_positive_numbers(-10, 2)
except AssertionError as e:
    print(f"Assertion error: {e}")
```

## 9. Exception Chaining and Context

**Preserve error context when re-raising exceptions:**

- `raise ... from ...` - Explicit chaining

- `raise` - Implicit chaining

- Helps track the original cause of errors


```python
def read_config_file(filename):
    """Example of exception chaining"""
    try:
        with open(filename, 'r') as file:
            import json
            config = json.load(file)
            return config
    except FileNotFoundError as e:
        # Chain the original exception
        raise ValueError(f"Configuration file '{filename}' not found") from e
    except json.JSONDecodeError as e:
        # Chain with more context
        raise ValueError(f"Invalid JSON in configuration file '{filename}'") from e

def process_data():
    """Example showing exception context"""
    try:
        config = read_config_file("nonexistent_config.json")
        return config
    except ValueError as e:
        print(f"Configuration error: {e}")
        print(f"Original cause: {e.__cause__}")
        # Re-raise with additional context
        raise RuntimeError("Failed to initialize application") from e

# Test exception chaining
try:
    process_data()
except RuntimeError as e:
    print(f"\nFinal error: {e}")
    print(f"Caused by: {e.__cause__}")
    print(f"Original cause: {e.__cause__.__cause__}")

# Example with suppress chaining
def clean_reraise():
    try:
        result = 10 / 0
    except ZeroDivisionError:
        # Suppress the original exception chain
        raise ValueError("Invalid calculation") from None

try:
    clean_reraise()
except ValueError as e:
    print(f"\nSuppressed chain error: {e}")
    print(f"Has cause: {e.__cause__}")  # Will be None
```

## 10. Error Handling Best Practices

**Guidelines for writing robust, maintainable code:**

‚úÖ **Be specific**: Catch specific exceptions, not generic `Exception`  

‚úÖ **Fail fast**: Use assertions to catch bugs early  

‚úÖ **Log errors**: Use logging instead of print for production code  

‚úÖ **Don't ignore**: Always handle or log exceptions  

‚úÖ **Clean up**: Use `finally` or context managers for cleanup  

‚úÖ **Document**: Specify what exceptions your functions can raise  

‚úÖ **Test**: Write tests for both success and failure cases


```python
# Example of good error handling practices
import logging

class DatabaseError(Exception):
    """Custom exception for database operations"""
    pass

class UserNotFoundError(DatabaseError):
    """Raised when user is not found in database"""
    pass

def get_user_by_id(user_id):
    """
    Retrieve user by ID from database.
    
    Args:
        user_id (int): The user ID to search for
        
    Returns:
        dict: User information
        
    Raises:
        TypeError: If user_id is not an integer
        UserNotFoundError: If user is not found
        DatabaseError: If database connection fails
    """
    # Input validation
    if not isinstance(user_id, int):
        raise TypeError(f"user_id must be an integer, got {type(user_id)}")
    
    if user_id <= 0:
        raise ValueError("user_id must be positive")
    
    # Simulate database lookup
    fake_database = {1: {"name": "Alice", "email": "alice@example.com"}}
    
    try:
        # Simulate potential database connection error
        if user_id > 100:
            raise ConnectionError("Database connection lost")
        
        if user_id not in fake_database:
            raise UserNotFoundError(f"User with ID {user_id} not found")
        
        user = fake_database[user_id]
        logging.info(f"Successfully retrieved user {user_id}")
        return user
        
    except ConnectionError as e:
        logging.error(f"Database connection failed: {e}")
        raise DatabaseError("Failed to connect to database") from e

# Example usage with proper error handling
def main():
    logging.basicConfig(level=logging.INFO)
    
    test_cases = [1, "invalid", -1, 2, 101]
    
    for user_id in test_cases:
        try:
            print(f"\nTrying to get user {user_id}:")
            user = get_user_by_id(user_id)
            print(f"Success: {user}")
            
        except TypeError as e:
            print(f"Type error: {e}")
        except ValueError as e:
            print(f"Value error: {e}")
        except UserNotFoundError as e:
            print(f"User not found: {e}")
        except DatabaseError as e:
            print(f"Database error: {e}")
            print(f"Original cause: {e.__cause__}")

# Run the example
main()
```

### **üéØ Quick Recap**
‚úÖ Use try-except to catch errors and prevent crashes

‚úÖ Catch specific exceptions for better error handling

‚úÖ else and finally provide structured error handling

‚úÖ Custom exceptions allow for clear, descriptive error messages

‚úÖ Know common Python error types for faster debugging

‚úÖ Use debugging techniques: print statements, logging, assertions

‚úÖ Exception chaining preserves error context

‚úÖ Follow best practices for robust, maintainable code

‚úÖ Debugging is an essential skill for reliable code

### **üìù Practice Exercises**

**Basic Level:**

1. Write a program that asks for two numbers and divides them. Handle:
   - ValueError for invalid inputs
   - ZeroDivisionError for division by zero

2. Create a custom exception called `PasswordTooShortError` if the entered password is less than 8 characters.

3. Demonstrate the use of `else` and `finally` in a simple program that reads a file.

4. Intentionally raise an exception if a negative number is entered for age.

**Intermediate Level:**

5. Write a function that catches different types of errors (IndexError, KeyError, TypeError) and prints specific messages for each.

6. Create a simple calculator with proper error handling and logging.

7. Use assertions to validate input in a function that calculates square roots.

8. Write a program that demonstrates exception chaining when processing user data.

**Advanced Level:**

9. Build a file processor that handles multiple types of errors and uses logging instead of print statements.

10. Create a custom exception hierarchy for a banking system (InsufficientFundsError, InvalidAccountError, etc.).

11. Write a robust function with proper documentation that specifies all possible exceptions it can raise.

12. Implement a retry mechanism that attempts an operation multiple times before giving up.

